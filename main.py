# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m7pAt9G-dFeXerLj1O92vHRtsIELmasO
"""
import os
import time
import logging
import asyncio
import pandas as pd
import numpy as np
from fastapi import FastAPI, Form
from twilio.rest import Client
from sentence_transformers import SentenceTransformer
import faiss
import nest_asyncio
from pyngrok import ngrok
import uvicorn

from dotenv import load_dotenv
import os

load_dotenv() 

CSV_PATH = "furniture_products.csv"   # path to your CSV
NGROK_AUTH_TOKEN = os.environ.get("NGROK_AUTH_TOKEN", "")  # optional, set if you have one
TWILIO_SID = os.environ.get("TWILIO_SID", "YOUR_TWILIO_SID")
TWILIO_AUTH_TOKEN = os.environ.get("TWILIO_AUTH_TOKEN", "YOUR_TWILIO_AUTH_TOKEN")
TWILIO_WHATSAPP_NUMBER = os.environ.get("TWILIO_WHATSAPP_NUMBER", "whatsapp:+14155238886")  # sandbox default
PAGE_SIZE = 3  # products per page sent to user

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("whatsapp_rag")

if not os.path.exists(CSV_PATH):
    raise FileNotFoundError(f"CSV not found at {CSV_PATH}. Upload it or update CSV_PATH.")

df = pd.read_csv(CSV_PATH)
# ensure required columns exist
required_cols = ["Product_Name", "Description", "Category", "Color", "Price"]
for c in required_cols:
    if c not in df.columns:
        raise ValueError(f"CSV missing required column: {c}")

# optional image_url column
if "image_url" not in df.columns:
    df["image_url"] = None  # keep column present for uniform handling

# create combined text for embeddings (exclude Price)
df["combined_text"] = (
    df["Product_Name"].fillna("") + " " +
    df["Description"].fillna("") + " " +
    df["Category"].fillna("") + " " +
    df["Color"].fillna("")
)

logger.info("Loading embedding model and building FAISS index. This may take a while on first run.")
embed_model = SentenceTransformer("all-MiniLM-L6-v2")
embeddings = embed_model.encode(df["combined_text"].tolist(), show_progress_bar=True, convert_to_numpy=True).astype("float32")

dim = embeddings.shape[1]
index = faiss.IndexFlatL2(dim)
index.add(embeddings)
logger.info(f"FAISS index ready with {index.ntotal} items.")

client = Client(TWILIO_SID, TWILIO_AUTH_TOKEN)
print(client.api.accounts.list(limit=1))

conversation_memory = {}

def search_products(query, top_k=20):
    """Return top_k product indices and DataFrame slice for query."""
    q_emb = embed_model.encode([query], convert_to_numpy=True).astype("float32")
    D, I = index.search(q_emb, top_k)
    indices = I[0].tolist()
    results_df = df.iloc[indices].reset_index(drop=True)
    return indices, results_df

def format_product_message(row, idx):
    """Return a WhatsApp-friendly message string for a product row (row is a Series)."""
    price_val = row.get("Price", "")
    try:
        price_str = f"‚Çπ{int(price_val):,}"
    except Exception:
        price_str = str(price_val)
    text = (
        f"üõãÔ∏è *{row['Product_Name']}*\n"
        f"Category: {row['Category']}\n"
        f"Color: {row['Color']}\n"
        f"Price: {price_str}\n"
        f"Description: {row['Description']}\n"
    )
    # Buy link fallback: if you have a real product page, replace below
    text += f"Buy here: https://example.com/product{idx}\n"
    return text

def send_product_to_user(user_whatsapp, row, idx):
    """Send one product as WhatsApp message via Twilio, image optional."""
    body = format_product_message(row, idx)
    media = None
    img = row.get("image_url", None)
    if pd.notna(img) and img:
        media = [img]
    message = client.messages.create(
        from_=TWILIO_WHATSAPP_NUMBER,
        to=user_whatsapp,
        body=body,
        media_url=media if media else None
    )
    return message.sid

nest_asyncio.apply()
app = FastAPI()

@app.post("/whatsapp/webhook")
async def whatsapp_webhook(Body: str = Form(...), From: str = Form(...)):
    """
    Twilio will POST with form fields. We accept:
    Body (message text), From (whatsapp:+<number>)
    """
    try:
        user_text = Body.strip()
        user_id = From.strip()

        logger.info("====================================")
        logger.info(f"Incoming from {user_id}: {user_text}")

        # Normalize simple control commands
        low = user_text.strip().lower()
        is_more = low in ("more", "more please", "show more", "more products")
        is_restart = low in ("restart", "reset", "start over", "clear")

        # If user asked for "more"
        if is_more:
            mem = conversation_memory.get(user_id)
            if not mem:
                reply = "No active session. Send a product query, for example: 'blue sofa'."
                # For sandbox testing also return JSON
                return {"status": "ok", "message": reply}
            # get next page
            indices_list = mem["results"]
            offset = mem.get("offset", 0)
            if offset >= len(indices_list):
                reply = "No more products to show."
                return {"status": "ok", "message": reply}
            page_indices = indices_list[offset: offset + PAGE_SIZE]
            sent = []
            for idx in page_indices:
                row = df.iloc[idx]
                sid = send_product_to_user(user_id, row, idx)
                sent.append({"Product_Name": row["Product_Name"], "sid": sid})
            mem["offset"] = offset + PAGE_SIZE
            logger.info(f"Sent {len(page_indices)} more products to {user_id}.")
            # Return debug JSON with the products sent
            sent_rows = df.iloc[page_indices][["Product_Name","Description","Category","Color","Price","image_url"]].to_dict(orient="records")
            return {"status": "success", "sent_count": len(page_indices), "sent_products": sent_rows}

        # If restart command
        if is_restart:
            if user_id in conversation_memory:
                conversation_memory.pop(user_id, None)
            reply = "Session reset. Send a new query to start again, for example: 'modern wooden dining table'."
            return {"status": "ok", "message": reply}

        # Normal new query:
        # 1) Search and store result indices in memory
        indices, results_df = search_products(user_text, top_k=50)
        if len(indices) == 0:
            reply = "Sorry, I could not find matching products. Try a different query."
            return {"status": "ok", "message": reply}

        conversation_memory[user_id] = {
            "last_query": user_text,
            "results": indices,   # list of df integer indices
            "offset": 0
        }

        # 2) Send first page_size products
        page_indices = indices[0: PAGE_SIZE]
        sent = []
        for idx in page_indices:
            row = df.iloc[idx]
            sid = send_product_to_user(user_id, row, idx)
            sent.append({"Product_Name": row["Product_Name"], "sid": sid})
        conversation_memory[user_id]["offset"] = PAGE_SIZE

        logger.info(f"Sent first {len(page_indices)} products to {user_id} for query: {user_text}")

        # 3) Return full debug JSON for Postman showing these product details
        sent_rows = df.iloc[page_indices][["Product_Name","Description","Category","Color","Price","image_url"]].to_dict(orient="records")
        return {
            "status": "success",
            "sent_count": len(page_indices),
            "sent_products": sent_rows,
            "note": "To get more results, reply 'more' in WhatsApp."
        }

    except Exception as e:
        logger.exception("Webhook error")
        return {"status": "error", "error": str(e)}


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8001)


# def start_server_ngrok(port: int = 8000, ngrok_token: str = None):
#     # authenticate ngrok if token provided
#     if ngrok_token:
#         ngrok.set_auth_token(ngrok_token)
#     public_url = ngrok.connect(port)
#     logger.info(f"Public URL: {public_url}")
#     # start uvicorn server as background task
#     config = uvicorn.Config(app=app, host="0.0.0.0", port=port, log_level="info")
#     server = uvicorn.Server(config)
#     asyncio.create_task(server.serve())
#     return public_url

# from pyngrok import ngrok
# ngrok.set_auth_token("30XulEwAKdVQW7w0E2hKA53bnIw_74kn994Q4Xb1w6AS4ePeB")

# import threading
# import uvicorn
# from pyngrok import ngrok

# # Kill any previous tunnels
# ngrok.kill()

# # Create tunnel
# public_url = ngrok.connect(8000)
# print("Public URL for Twilio Webhook:", public_url.public_url)

# # Function to run FastAPI app in background
# def run_app():
#     uvicorn.run(app, host="0.0.0.0", port=8000)

# # Start the app in background
# thread = threading.Thread(target=run_app, daemon=True)
# thread.start()



